/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201601121427.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_COM_IVIS_DATCMANAGER_DATC_Manager_Types_HPP_
#define V1_COM_IVIS_DATCMANAGER_DATC_Manager_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace ivis {
namespace DATCManager {

struct DATCManagerTypes {
    struct TemperatureRange : CommonAPI::Struct<double, double> {
    	
    	TemperatureRange() {
    	}
    	TemperatureRange(const double &_minimum, const double &_maximum)
    	{
    		std::get<0>(values_) = _minimum;
    		std::get<1>(values_) = _maximum;
    	}
    	inline const double &getMinimum() const { return std::get<0>(values_); }
    	inline void setMinimum(const double &_value) { std::get<0>(values_) = _value; }
    	inline const double &getMaximum() const { return std::get<1>(values_); }
    	inline void setMaximum(const double &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const TemperatureRange& _other) const {
                return (getMinimum() == _other.getMinimum() && getMaximum() == _other.getMaximum());
        }
    	inline bool operator!=(const TemperatureRange &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct EAreaType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DRIVER = 0,
            PASSENGER = 1,
            REAR_DRIVER = 2,
            REAR_PASSENGER = 3
        };
        
        EAreaType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DRIVER)) {}
        EAreaType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DRIVER):
                case static_cast<int32_t>(Literal::PASSENGER):
                case static_cast<int32_t>(Literal::REAR_DRIVER):
                case static_cast<int32_t>(Literal::REAR_PASSENGER):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EAreaType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EAreaType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EAreaType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EAreaType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EAreaType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EAreaType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct TargetTemperature : CommonAPI::Struct<EAreaType, double> {
    	
    	TargetTemperature() {
    	}
    	TargetTemperature(const EAreaType &_areaType, const double &_temperature)
    	{
    		std::get<0>(values_) = _areaType;
    		std::get<1>(values_) = _temperature;
    	}
    	inline const EAreaType &getAreaType() const { return std::get<0>(values_); }
    	inline void setAreaType(const EAreaType &_value) { std::get<0>(values_) = _value; }
    	inline const double &getTemperature() const { return std::get<1>(values_); }
    	inline void setTemperature(const double &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const TargetTemperature& _other) const {
                return (getAreaType() == _other.getAreaType() && getTemperature() == _other.getTemperature());
        }
    	inline bool operator!=(const TargetTemperature &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct EHvacFanDirection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            FRONT_PANEL = 0,
            FLOOR_DUCT = 1,
            FRONT_AND_FLOOR = 2,
            DEFROSTER_AND_FLOOR = 3,
            DEFROSTER = 4
        };
        
        EHvacFanDirection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::FRONT_PANEL)) {}
        EHvacFanDirection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::FRONT_PANEL):
                case static_cast<int32_t>(Literal::FLOOR_DUCT):
                case static_cast<int32_t>(Literal::FRONT_AND_FLOOR):
                case static_cast<int32_t>(Literal::DEFROSTER_AND_FLOOR):
                case static_cast<int32_t>(Literal::DEFROSTER):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EHvacFanDirection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EHvacFanDirection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EHvacFanDirection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EHvacFanDirection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EHvacFanDirection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EHvacFanDirection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct FanDirection : CommonAPI::Struct<EAreaType, EHvacFanDirection> {
    	
    	FanDirection() {
    	}
    	FanDirection(const EAreaType &_areaType, const EHvacFanDirection &_fanDirection)
    	{
    		std::get<0>(values_) = _areaType;
    		std::get<1>(values_) = _fanDirection;
    	}
    	inline const EAreaType &getAreaType() const { return std::get<0>(values_); }
    	inline void setAreaType(const EAreaType &_value) { std::get<0>(values_) = _value; }
    	inline const EHvacFanDirection &getFanDirection() const { return std::get<1>(values_); }
    	inline void setFanDirection(const EHvacFanDirection &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const FanDirection& _other) const {
                return (getAreaType() == _other.getAreaType() && getFanDirection() == _other.getFanDirection());
        }
    	inline bool operator!=(const FanDirection &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct FanSpeedRange : CommonAPI::Struct<uint16_t, uint16_t> {
    	
    	FanSpeedRange() {
    	}
    	FanSpeedRange(const uint16_t &_minimum, const uint16_t &_maximum)
    	{
    		std::get<0>(values_) = _minimum;
    		std::get<1>(values_) = _maximum;
    	}
    	inline const uint16_t &getMinimum() const { return std::get<0>(values_); }
    	inline void setMinimum(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getMaximum() const { return std::get<1>(values_); }
    	inline void setMaximum(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const FanSpeedRange& _other) const {
                return (getMinimum() == _other.getMinimum() && getMaximum() == _other.getMaximum());
        }
    	inline bool operator!=(const FanSpeedRange &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct FanSpeed : CommonAPI::Struct<EAreaType, uint16_t> {
    	
    	FanSpeed() {
    	}
    	FanSpeed(const EAreaType &_areaType, const uint16_t &_fanSpeed)
    	{
    		std::get<0>(values_) = _areaType;
    		std::get<1>(values_) = _fanSpeed;
    	}
    	inline const EAreaType &getAreaType() const { return std::get<0>(values_); }
    	inline void setAreaType(const EAreaType &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getFanSpeed() const { return std::get<1>(values_); }
    	inline void setFanSpeed(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const FanSpeed& _other) const {
                return (getAreaType() == _other.getAreaType() && getFanSpeed() == _other.getFanSpeed());
        }
    	inline bool operator!=(const FanSpeed &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct EDefrostTarget : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            WIND_SHIELD = 0,
            SIDE_MIRROR = 1,
            REAR = 2,
            WINDOW = 3
        };
        
        EDefrostTarget() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::WIND_SHIELD)) {}
        EDefrostTarget(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::WIND_SHIELD):
                case static_cast<int32_t>(Literal::SIDE_MIRROR):
                case static_cast<int32_t>(Literal::REAR):
                case static_cast<int32_t>(Literal::WINDOW):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EDefrostTarget &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EDefrostTarget &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EDefrostTarget &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EDefrostTarget &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EDefrostTarget &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EDefrostTarget &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct Defrost : CommonAPI::Struct<EDefrostTarget, bool> {
    	
    	Defrost() {
    		std::get<1>(values_) = false;
    	}
    	Defrost(const EDefrostTarget &_defrostTarget, const bool &_on)
    	{
    		std::get<0>(values_) = _defrostTarget;
    		std::get<1>(values_) = _on;
    	}
    	inline const EDefrostTarget &getDefrostTarget() const { return std::get<0>(values_); }
    	inline void setDefrostTarget(const EDefrostTarget &_value) { std::get<0>(values_) = _value; }
    	inline const bool &getOn() const { return std::get<1>(values_); }
    	inline void setOn(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Defrost& _other) const {
                return (getDefrostTarget() == _other.getDefrostTarget() && getOn() == _other.getOn());
        }
    	inline bool operator!=(const Defrost &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct SeatHeater : CommonAPI::Struct<EAreaType, bool> {
    	
    	SeatHeater() {
    		std::get<1>(values_) = false;
    	}
    	SeatHeater(const EAreaType &_areaType, const bool &_on)
    	{
    		std::get<0>(values_) = _areaType;
    		std::get<1>(values_) = _on;
    	}
    	inline const EAreaType &getAreaType() const { return std::get<0>(values_); }
    	inline void setAreaType(const EAreaType &_value) { std::get<0>(values_) = _value; }
    	inline const bool &getOn() const { return std::get<1>(values_); }
    	inline void setOn(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const SeatHeater& _other) const {
                return (getAreaType() == _other.getAreaType() && getOn() == _other.getOn());
        }
    	inline bool operator!=(const SeatHeater &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct SeatCooler : CommonAPI::Struct<EAreaType, bool> {
    	
    	SeatCooler() {
    		std::get<1>(values_) = false;
    	}
    	SeatCooler(const EAreaType &_areaType, const bool &_on)
    	{
    		std::get<0>(values_) = _areaType;
    		std::get<1>(values_) = _on;
    	}
    	inline const EAreaType &getAreaType() const { return std::get<0>(values_); }
    	inline void setAreaType(const EAreaType &_value) { std::get<0>(values_) = _value; }
    	inline const bool &getOn() const { return std::get<1>(values_); }
    	inline void setOn(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const SeatCooler& _other) const {
                return (getAreaType() == _other.getAreaType() && getOn() == _other.getOn());
        }
    	inline bool operator!=(const SeatCooler &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<DATCManagerTypes::TargetTemperature> TargetTemperatures;
    typedef std::vector<DATCManagerTypes::EHvacFanDirection> SupportedFanDirectionList;
    typedef std::vector<DATCManagerTypes::FanDirection> FanDirections;
    typedef std::vector<DATCManagerTypes::FanSpeed> FanSpeeds;
    typedef std::vector<DATCManagerTypes::EDefrostTarget> SupportedDefrostTargetList;
    typedef std::vector<DATCManagerTypes::Defrost> Defrosts;
    typedef std::vector<DATCManagerTypes::SeatHeater> SeatHeaters;
    typedef std::vector<DATCManagerTypes::SeatCooler> SeatCoolers;
    
    struct ETemperatureMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CELSIUS = 0,
            FRENHEIT = 1
        };
        
        ETemperatureMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CELSIUS)) {}
        ETemperatureMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CELSIUS):
                case static_cast<int32_t>(Literal::FRENHEIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ETemperatureMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ETemperatureMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ETemperatureMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ETemperatureMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ETemperatureMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ETemperatureMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct EDatcControlResult : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            FAIL_RANGE_OUT = 1,
            FAIL_BUSY = 2,
            FAIL_NO_TARGET = 3,
            FAIL_UNKNOWN = 4
        };
        
        EDatcControlResult() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        EDatcControlResult(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FAIL_RANGE_OUT):
                case static_cast<int32_t>(Literal::FAIL_BUSY):
                case static_cast<int32_t>(Literal::FAIL_NO_TARGET):
                case static_cast<int32_t>(Literal::FAIL_UNKNOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EDatcControlResult &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EDatcControlResult &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EDatcControlResult &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EDatcControlResult &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EDatcControlResult &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EDatcControlResult &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.ivis.DATCManager.DATCManagerTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct DATCManagerTypes

} // namespace DATCManager
} // namespace ivis
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for ETemperatureMode
    template<>
    struct hash<::v1::com::ivis::DATCManager::DATCManagerTypes::ETemperatureMode> {
        inline size_t operator()(const ::v1::com::ivis::DATCManager::DATCManagerTypes::ETemperatureMode& eTemperatureMode) const {
            return static_cast<int32_t>(eTemperatureMode);
        }
    };
    //Hash for EHvacFanDirection
    template<>
    struct hash<::v1::com::ivis::DATCManager::DATCManagerTypes::EHvacFanDirection> {
        inline size_t operator()(const ::v1::com::ivis::DATCManager::DATCManagerTypes::EHvacFanDirection& eHvacFanDirection) const {
            return static_cast<int32_t>(eHvacFanDirection);
        }
    };
    //Hash for EDefrostTarget
    template<>
    struct hash<::v1::com::ivis::DATCManager::DATCManagerTypes::EDefrostTarget> {
        inline size_t operator()(const ::v1::com::ivis::DATCManager::DATCManagerTypes::EDefrostTarget& eDefrostTarget) const {
            return static_cast<int32_t>(eDefrostTarget);
        }
    };
    //Hash for EAreaType
    template<>
    struct hash<::v1::com::ivis::DATCManager::DATCManagerTypes::EAreaType> {
        inline size_t operator()(const ::v1::com::ivis::DATCManager::DATCManagerTypes::EAreaType& eAreaType) const {
            return static_cast<int32_t>(eAreaType);
        }
    };
    //Hash for EDatcControlResult
    template<>
    struct hash<::v1::com::ivis::DATCManager::DATCManagerTypes::EDatcControlResult> {
        inline size_t operator()(const ::v1::com::ivis::DATCManager::DATCManagerTypes::EDatcControlResult& eDatcControlResult) const {
            return static_cast<int32_t>(eDatcControlResult);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_IVIS_DATCMANAGER_DATC_Manager_Types_HPP_
